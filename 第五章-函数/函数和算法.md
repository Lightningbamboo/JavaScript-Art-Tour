## 函数和算法

---

### 算法的基础

函数不仅是一种管理程序复杂性的工具，更为算法的实现提供了基础性的保障。算法在人类历史长河的智慧中诞生，历史上最著名的一个数学算法是以希腊数学家欧几里德的名字命名的。在欧几里德的数学著作《几何原本》中，他描述了一个求两个整数 x 和 y *最大公约数*（greatest common divisor, gcd）的过程，即一个可以同时整除 x 和 y 的最大整数的算法。例如，49 和 35 的 gcd 是 7，6 和 18 的 gcd 是 6，32 和 33 的 gcd 是 1.欧几里德算法可以描述如下：

1. 用 x 除以 y 并计算余数 r。
2. 若 r 等于 0，则算法结束，最大公约数是 y。
3. 若 r 不等于 0，则令 x 的值为 y，y 的值为 r。
4. 回到步骤 1。

这个算法可以很容易地用 JavaScript 代码描述：

```javascript
let gcd = (x, y) => {
    let r = x % y;
    while (r != 0) {
        x = y;
        y = r;
        r = x % y;
    }
    return y;
}
```

这个算法实现起来相当简单，但相比你自己可能发现的任何计算策略显得更有效率。事实上，欧几里德算法至今在包括网络安全的加密协议实现等很多情况下都得到了广泛的应用。

同时，我们很难清晰明确的看出该算法为什么会得到正确的结果。它的正确性已经在《几何原本》第七章命题二中得到了证明。虽然并不是总有证据来证明算法对计算机应用的驱动作用，但这些证据能让你对程序的正确性更有信心。

除了计算最大公约数以外，生活中我们还会不可避免的遇到一些算法问题，它们往往代表了我们需要解决和思考的一些实际问题。例如，当我们有了收入之后，会有意识地对财产进行储蓄或投资。银行或理财机构对于存款或投资的收益都做了详细的规划。如果我们要手动计算这些问题，不仅非常繁琐，还要冒着可能出错的风险。作为人类，我们只需要思考解决问题的方式，而重复性的繁杂工作都应该交给计算机来处理，使它根据我们的指挥更好地为我们服务。

定期存款的本金与总利息之和的计算遵循下面的公式：
$$
本利和＝本金(1 + 利率(\frac{存期}{12}))^{(时长/存期)}
$$
我们可以根据这个公式直观地写出用于计算的函数：

```javascript
let sum = (principal, rate, savingperiod, lastperiod) => {
    let value = principal * (Math.pow(
        (1 + rate * (
            savingperiod / 12
        )), 
        Math.floor(lastperiod / savingperiod))); 
    return value.toFixed(2);
};
```

这个函数具有四个参数，反映了实际应用中的复杂性，而函数起到的作用就是隐藏复杂性。`sum` 函数隐藏公式的算法细节细节，向外提供一个统一的计算方式。在进行计算时，我们应当且只应当关注每次计算时的值，而不必将精力放在实际的计算过程中，就像计算器提供的方便的数学函数，我们只需将它当成和四则运算没有什么区别的简单运算，当需要用到的值发生改变时，就改变它的参数——函数的意义就是这样简单。

- `principal` ：本金
- `rate`：利率
- `savingperiod`：存期
- `lastperiod`：时长

它的核心实际上只有一行表达式，但是它有些复杂，因此我们将其拆分成多行，以便于阅读。计算完成后，我们将得到的值取两位小数，就是最后的结果。

使用一些值来测试这个函数：

```javascript
alert(sum(100, 0.06, 5, 16));    // 107.69
alert(sum(1000, 0.01, 12, 19));  // 1010.00
alert(sum(520, 0.5, 3, 17));     // 937.06
alert(sum(10, 0.1, 6, 24));      // 12.16
alert(sum(6622, 0.087, 9, 31));  // 8004.68
```

就像我们在中学时学到的数学函数一样，`sum` 这样的函数可以简单地看做是结果与一组值之间的映射。这样单纯地只进行一些计算并返回一个值，而不做其他什么事情的函数称为*纯函数*。





### 组合函数

想象一下，假如我们在玩一个掷骰子游戏，我们手中有两枚骰子，每次同时抛掷，那么它们的随机点数共有多少种组合呢？

![骰子](assets/th-1555712687236.jpg)

上图显示了 6 + 4 这一点数组合，而实际上我们也可能会得到 2 + 3，4 + 1, 6 + 3……共有十五种可能组合。作为一个编程者，应该思考一个更加普遍的问题：给定一个含有 $$ n $$ 个元素的集合，可以从中得到多少个包含 $$ k $$ 元素的子集？可以通过如下的*组合函数*（combinations function） `C(n, k)` 来得到答案：
$$
C(n, k) = \frac{N!}{k \times (n - k)!}
$$
其中，感叹号代表了阶乘函数，表明为从 1 到所指定的值中所有整数的乘积。我们可能还想查看对于更大的 $$ n $$ 和 $$ k $$ 而言有多少种组合，因此可以写出这样的程序来方便地计算。

![1555713818684](assets/1555713818684.png)

![1555713844215](assets/1555713844215.png)

![1555713869213](assets/1555713869213.png)

这个程序分别向用户请求 $$ n $$ 和 $$ k $$ 的值，然后显示函数 `C(n, k)` 的值，代码实现如下。

```javascript
let fact = (n) => {
  let result = 1;
  for (let i = 1; i <= n; i += 1) {
    result *= i;
  }
  return result;
}

let combinations = (n, k) => {
  return Math.floor(
      fact(n) / (fact(k) * fact(n - k))
  );
}

let n = +parseInt(prompt("请输入组合物体的总数："));
let k = +parseInt(prompt("请输入每次组合的个数："));
let c = combinations(n, k);
alert(`C(k, n) = ${c}`);
```

正如你所看到的， Combinations 程序划分为三个函数，借用第四章中定义的 `fact` 函数来计算所需要的阶乘结果，再利用 `combinations` 函数计算 `C(n, k)` 的值。